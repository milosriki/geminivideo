/**
 * Agent Trigger Service
 * Invokes AI agents when winners are detected to:
 * - Analyze why the ad won
 * - Extract winning patterns
 * - Generate improvement suggestions
 * - Create similar ad concepts
 */

import axios, { AxiosError } from 'axios';
import { logger } from '../utils/logger';
import { DatabaseService } from './database';

/**
 * Winner data structure from ad performance tracking
 */
export interface Winner {
  id: string;
  adId: string;
  campaignId?: string;
  creative: {
    videoUrl?: string;
    thumbnailUrl?: string;
    headline?: string;
    description?: string;
    duration?: number;
    format?: string;
  };
  performance: {
    roas: number;
    ctr: number;
    conversionRate: number;
    impressions?: number;
    clicks?: number;
    conversions?: number;
    spend?: number;
    revenue?: number;
  };
  targeting: {
    demographics?: any;
    interests?: string[];
    locations?: string[];
    platforms?: string[];
  };
  copy: string;
  timestamp: string;
  metadata?: Record<string, any>;
}

/**
 * AI Agent analysis result structure
 */
export interface AgentAnalysis {
  winnerId: string;
  winningFactors: string[];
  patterns: WinningPattern[];
  improvements: string[];
  newConcepts: AdConcept[];
  technicalInsights: TechnicalInsight[];
  confidence: number;
  timestamp: string;
  agentVersion?: string;
}

/**
 * Winning pattern extracted by AI
 */
export interface WinningPattern {
  category: 'creative' | 'copy' | 'targeting' | 'timing' | 'format';
  pattern: string;
  strength: number;
  examples: string[];
  applicability: 'universal' | 'industry_specific' | 'seasonal';
}

/**
 * New ad concept generated by AI
 */
export interface AdConcept {
  title: string;
  description: string;
  hook: string;
  visualStyle: string;
  targetAudience: string;
  estimatedPerformance: {
    roas: number;
    ctr: number;
    confidence: number;
  };
  similarToWinnerId: string;
}

/**
 * Technical insights from AI analysis
 */
export interface TechnicalInsight {
  type: 'video_quality' | 'audio' | 'pacing' | 'editing' | 'composition';
  insight: string;
  importance: 'high' | 'medium' | 'low';
  recommendation: string;
}

/**
 * LangGraph agent request payload
 */
interface LangGraphRequest {
  assistant_id: string;
  input: {
    winner_data: Winner;
    task: string;
    extract_patterns: boolean;
    generate_improvements: boolean;
    create_new_concepts: boolean;
    analysis_depth?: 'quick' | 'standard' | 'deep';
  };
  config?: {
    configurable?: Record<string, any>;
  };
  metadata?: Record<string, any>;
}

/**
 * LangGraph agent response
 */
interface LangGraphResponse {
  run_id: string;
  status: string;
  output?: {
    winning_factors?: string[];
    patterns?: any[];
    improvements?: string[];
    new_concepts?: any[];
    technical_insights?: any[];
    confidence?: number;
  };
  error?: string;
}

/**
 * Batch analysis result
 */
export interface BatchAnalysisResult {
  total: number;
  successful: number;
  failed: number;
  results: Map<string, AgentAnalysis>;
  errors: Map<string, string>;
  duration: number;
}

/**
 * Agent Trigger Service Class
 * Manages AI agent invocations for winner analysis
 */
export class AgentTrigger {
  private langgraphUrl: string;
  private db: DatabaseService;
  private ragUrl: string;
  private defaultTimeout: number = 60000; // 60 seconds
  private maxRetries: number = 3;
  private retryDelay: number = 2000; // 2 seconds

  constructor() {
    this.langgraphUrl = process.env.LANGGRAPH_URL || 'http://localhost:2024';
    this.ragUrl = process.env.RAG_SERVICE_URL || 'http://localhost:8001';
    this.db = DatabaseService.getInstance();

    logger.info('AgentTrigger initialized', {
      langgraphUrl: this.langgraphUrl,
      ragUrl: this.ragUrl,
    });
  }

  /**
   * Trigger AI agent analysis for a single winner
   * @param winner - Winner ad data
   * @param analysisDepth - Depth of analysis: 'quick', 'standard', or 'deep'
   * @returns AgentAnalysis with insights and recommendations
   */
  async triggerAgentOnWinner(
    winner: Winner,
    analysisDepth: 'quick' | 'standard' | 'deep' = 'standard'
  ): Promise<AgentAnalysis> {
    const startTime = Date.now();
    logger.info(`Triggering agent analysis for winner ${winner.id}`, {
      winnerId: winner.id,
      adId: winner.adId,
      roas: winner.performance.roas,
      analysisDepth,
    });

    try {
      // Validate winner data
      this.validateWinner(winner);

      // Build LangGraph request
      const request: LangGraphRequest = {
        assistant_id: 'winner-analyzer',
        input: {
          winner_data: winner,
          task: 'analyze_winner',
          extract_patterns: true,
          generate_improvements: true,
          create_new_concepts: true,
          analysis_depth: analysisDepth,
        },
        metadata: {
          source: 'agent-trigger-service',
          timestamp: new Date().toISOString(),
          winnerId: winner.id,
        },
      };

      // Call LangGraph agent with retry logic
      const response = await this.callLangGraphWithRetry(request);

      // Transform response to AgentAnalysis
      const analysis = this.transformResponse(winner.id, response);

      // Store analysis in database
      await this.storeAnalysis(winner.id, analysis);

      // Index patterns to RAG system
      if (analysis.patterns.length > 0) {
        await this.indexPatternsToRAG(winner.id, analysis.patterns);
      }

      const duration = Date.now() - startTime;
      logger.info(`Agent analysis completed for winner ${winner.id}`, {
        winnerId: winner.id,
        patternCount: analysis.patterns.length,
        conceptCount: analysis.newConcepts.length,
        confidence: analysis.confidence,
        duration,
      });

      return analysis;
    } catch (error) {
      const duration = Date.now() - startTime;
      logger.error(`Agent analysis failed for winner ${winner.id}`, {
        winnerId: winner.id,
        error: error instanceof Error ? error.message : String(error),
        duration,
      });
      throw error;
    }
  }

  /**
   * Trigger batch analysis for multiple winners
   * @param winners - Array of winner ads
   * @param concurrency - Number of concurrent analyses (default: 5)
   * @returns BatchAnalysisResult with all results and errors
   */
  async triggerBatchAnalysis(
    winners: Winner[],
    concurrency: number = 5
  ): Promise<BatchAnalysisResult> {
    const startTime = Date.now();
    logger.info(`Starting batch analysis for ${winners.length} winners`, {
      totalWinners: winners.length,
      concurrency,
    });

    const results = new Map<string, AgentAnalysis>();
    const errors = new Map<string, string>();

    // Process winners in batches
    for (let i = 0; i < winners.length; i += concurrency) {
      const batch = winners.slice(i, i + concurrency);
      const batchPromises = batch.map(async (winner) => {
        try {
          const analysis = await this.triggerAgentOnWinner(winner);
          results.set(winner.id, analysis);
          return { winnerId: winner.id, success: true };
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : String(error);
          errors.set(winner.id, errorMsg);
          logger.error(`Failed to analyze winner ${winner.id} in batch`, {
            winnerId: winner.id,
            error: errorMsg,
          });
          return { winnerId: winner.id, success: false };
        }
      });

      await Promise.all(batchPromises);

      logger.info(`Completed batch ${Math.floor(i / concurrency) + 1}`, {
        processed: Math.min(i + concurrency, winners.length),
        total: winners.length,
      });
    }

    const duration = Date.now() - startTime;
    const batchResult: BatchAnalysisResult = {
      total: winners.length,
      successful: results.size,
      failed: errors.size,
      results,
      errors,
      duration,
    };

    logger.info('Batch analysis completed', {
      total: batchResult.total,
      successful: batchResult.successful,
      failed: batchResult.failed,
      duration: batchResult.duration,
    });

    return batchResult;
  }

  /**
   * Get historical analysis for a winner
   * @param winnerId - Winner ID
   * @returns AgentAnalysis or null if not found
   */
  async getAnalysis(winnerId: string): Promise<AgentAnalysis | null> {
    try {
      const client = this.db.getClient();

      // Query from KnowledgeDocument table (storing as knowledge)
      const doc = await client.knowledgeDocument.findFirst({
        where: {
          metadata: {
            path: ['winnerId'],
            equals: winnerId,
          },
        },
        orderBy: {
          createdAt: 'desc',
        },
      });

      if (!doc || !doc.content) {
        return null;
      }

      return JSON.parse(doc.content) as AgentAnalysis;
    } catch (error) {
      logger.error(`Failed to get analysis for winner ${winnerId}`, {
        winnerId,
        error: error instanceof Error ? error.message : String(error),
      });
      return null;
    }
  }

  /**
   * Search for similar winning patterns
   * @param pattern - Pattern description
   * @param limit - Max results to return
   * @returns Array of matching patterns
   */
  async searchSimilarPatterns(
    pattern: string,
    limit: number = 10
  ): Promise<WinningPattern[]> {
    try {
      logger.info('Searching for similar patterns', { pattern, limit });

      const response = await axios.post(
        `${this.ragUrl}/search`,
        {
          query: pattern,
          limit,
          filter: { type: 'winning_pattern' },
        },
        { timeout: 10000 }
      );

      return response.data.results || [];
    } catch (error) {
      logger.error('Failed to search patterns', {
        pattern,
        error: error instanceof Error ? error.message : String(error),
      });
      return [];
    }
  }

  /**
   * Validate winner data before analysis
   */
  private validateWinner(winner: Winner): void {
    if (!winner.id) {
      throw new Error('Winner ID is required');
    }
    if (!winner.adId) {
      throw new Error('Ad ID is required');
    }
    if (!winner.performance || typeof winner.performance.roas !== 'number') {
      throw new Error('Valid performance data with ROAS is required');
    }
    if (!winner.copy || winner.copy.trim().length === 0) {
      throw new Error('Ad copy is required');
    }
  }

  /**
   * Call LangGraph agent with retry logic
   */
  private async callLangGraphWithRetry(
    request: LangGraphRequest,
    attempt: number = 1
  ): Promise<LangGraphResponse> {
    try {
      const response = await axios.post<LangGraphResponse>(
        `${this.langgraphUrl}/runs`,
        request,
        {
          timeout: this.defaultTimeout,
          headers: {
            'Content-Type': 'application/json',
          },
        }
      );

      // Check if the run completed successfully
      if (response.data.status === 'error') {
        throw new Error(`LangGraph error: ${response.data.error}`);
      }

      return response.data;
    } catch (error) {
      const axiosError = error as AxiosError;

      // Retry on network errors or 5xx errors
      const shouldRetry =
        attempt < this.maxRetries &&
        (axiosError.code === 'ECONNREFUSED' ||
          axiosError.code === 'ETIMEDOUT' ||
          (axiosError.response?.status && axiosError.response.status >= 500));

      if (shouldRetry) {
        logger.warn(`LangGraph call failed, retrying (${attempt}/${this.maxRetries})`, {
          error: axiosError.message,
          attempt,
        });

        await this.sleep(this.retryDelay * attempt);
        return this.callLangGraphWithRetry(request, attempt + 1);
      }

      throw new Error(`LangGraph API error: ${axiosError.message}`);
    }
  }

  /**
   * Transform LangGraph response to AgentAnalysis
   */
  private transformResponse(winnerId: string, response: LangGraphResponse): AgentAnalysis {
    const output = response.output || {};

    return {
      winnerId,
      winningFactors: output.winning_factors || [],
      patterns: (output.patterns || []).map((p: any) => ({
        category: p.category || 'creative',
        pattern: p.pattern || '',
        strength: p.strength || 0.5,
        examples: p.examples || [],
        applicability: p.applicability || 'universal',
      })),
      improvements: output.improvements || [],
      newConcepts: (output.new_concepts || []).map((c: any) => ({
        title: c.title || '',
        description: c.description || '',
        hook: c.hook || '',
        visualStyle: c.visual_style || '',
        targetAudience: c.target_audience || '',
        estimatedPerformance: c.estimated_performance || {
          roas: 0,
          ctr: 0,
          confidence: 0,
        },
        similarToWinnerId: winnerId,
      })),
      technicalInsights: (output.technical_insights || []).map((t: any) => ({
        type: t.type || 'composition',
        insight: t.insight || '',
        importance: t.importance || 'medium',
        recommendation: t.recommendation || '',
      })),
      confidence: output.confidence || 0.7,
      timestamp: new Date().toISOString(),
      agentVersion: response.run_id,
    };
  }

  /**
   * Store analysis in database as knowledge document
   */
  private async storeAnalysis(winnerId: string, analysis: AgentAnalysis): Promise<void> {
    try {
      const client = this.db.getClient();

      await client.knowledgeDocument.create({
        data: {
          title: `Winner Analysis: ${winnerId}`,
          content: JSON.stringify(analysis, null, 2),
          source: 'agent-trigger',
          type: 'winner_analysis',
          metadata: {
            winnerId,
            timestamp: analysis.timestamp,
            confidence: analysis.confidence,
            patternCount: analysis.patterns.length,
            conceptCount: analysis.newConcepts.length,
          },
          embedding: [], // Will be populated by RAG service
        },
      });

      logger.info(`Stored analysis for winner ${winnerId}`, {
        winnerId,
        patternCount: analysis.patterns.length,
      });
    } catch (error) {
      logger.error(`Failed to store analysis for winner ${winnerId}`, {
        winnerId,
        error: error instanceof Error ? error.message : String(error),
      });
      // Don't throw - analysis is still returned even if storage fails
    }
  }

  /**
   * Index winning patterns to RAG/FAISS system
   */
  private async indexPatternsToRAG(
    winnerId: string,
    patterns: WinningPattern[]
  ): Promise<void> {
    try {
      const documents = patterns.map((pattern, idx) => ({
        id: `${winnerId}_pattern_${idx}`,
        text: `${pattern.category}: ${pattern.pattern}`,
        metadata: {
          winnerId,
          category: pattern.category,
          strength: pattern.strength,
          applicability: pattern.applicability,
          type: 'winning_pattern',
        },
      }));

      await axios.post(
        `${this.ragUrl}/index`,
        { documents },
        {
          timeout: 30000,
          headers: { 'Content-Type': 'application/json' },
        }
      );

      logger.info(`Indexed ${patterns.length} patterns for winner ${winnerId}`, {
        winnerId,
        patternCount: patterns.length,
      });
    } catch (error) {
      logger.error(`Failed to index patterns for winner ${winnerId}`, {
        winnerId,
        error: error instanceof Error ? error.message : String(error),
      });
      // Don't throw - indexing failure shouldn't break the flow
    }
  }

  /**
   * Utility: Sleep for delay milliseconds
   */
  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  /**
   * Health check for agent service
   */
  async healthCheck(): Promise<{
    langgraph: boolean;
    rag: boolean;
    database: boolean;
  }> {
    const checks = {
      langgraph: false,
      rag: false,
      database: false,
    };

    // Check LangGraph
    try {
      await axios.get(`${this.langgraphUrl}/health`, { timeout: 5000 });
      checks.langgraph = true;
    } catch (error) {
      logger.warn('LangGraph health check failed', {
        error: error instanceof Error ? error.message : String(error),
      });
    }

    // Check RAG
    try {
      await axios.get(`${this.ragUrl}/health`, { timeout: 5000 });
      checks.rag = true;
    } catch (error) {
      logger.warn('RAG health check failed', {
        error: error instanceof Error ? error.message : String(error),
      });
    }

    // Check Database
    try {
      await this.db.getClient().$queryRaw`SELECT 1`;
      checks.database = true;
    } catch (error) {
      logger.warn('Database health check failed', {
        error: error instanceof Error ? error.message : String(error),
      });
    }

    return checks;
  }
}

// Export singleton instance
export const agentTrigger = new AgentTrigger();

// Export types
export type {
  LangGraphRequest,
  LangGraphResponse,
};

# Cursor AI Agent Rules for GeminiVideo
# These rules ensure all AI-generated code follows best practices and stays in sync

## ğŸš« CRITICAL RULES - NEVER VIOLATE

1. **NEVER edit production database directly**
   - All database changes MUST be via `supabase db diff -f <name>`
   - All SQL must be in `supabase/migrations/` as numbered files
   - Format: `supabase/migrations/YYYYMMDDHHMMSS_<description>.sql`

2. **NEVER use unpinned imports**
   - Always use `npm:@package@version` or `jsr:@package@version`
   - Example: `npm:@supabase/supabase-js@2.45.0`
   - Never: `import { createClient } from '@supabase/supabase-js'`

3. **NEVER skip RLS (Row Level Security)**
   - Every table MUST have RLS enabled
   - Every table MUST have policies for SELECT/INSERT/UPDATE/DELETE
   - Use `(SELECT auth.uid())` pattern for user-scoped data

4. **NEVER create tables without indexes**
   - Index all foreign keys
   - Index all columns used in WHERE clauses
   - Index all columns used in RLS policies

## ğŸ“ PROJECT STRUCTURE

```
geminivideo/
â”œâ”€â”€ supabase/
â”‚   â”œâ”€â”€ config.toml              # Supabase config
â”‚   â”œâ”€â”€ migrations/              # ALL SQL changes here
â”‚   â”‚   â””â”€â”€ YYYYMMDDHHMMSS_*.sql
â”‚   â”œâ”€â”€ seed.sql                 # Seed data (optional)
â”‚   â””â”€â”€ functions/               # Edge Functions
â”‚       â””â”€â”€ <function-name>/
â”‚           â””â”€â”€ index.ts
â”œâ”€â”€ .github/workflows/
â”‚   â””â”€â”€ supabase-deploy.yml      # Auto-deploy on merge
â””â”€â”€ .cursorrules                  # This file
```

## ğŸ—„ï¸ DATABASE MIGRATIONS

### When creating a new table:

```sql
-- 1. Create table
CREATE TABLE IF NOT EXISTS my_table (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    data JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- 2. Enable RLS
ALTER TABLE my_table ENABLE ROW LEVEL SECURITY;

-- 3. Create policies
CREATE POLICY "Users can view own data"
    ON my_table FOR SELECT
    USING ((SELECT auth.uid()) = user_id);

CREATE POLICY "Users can insert own data"
    ON my_table FOR INSERT
    WITH CHECK ((SELECT auth.uid()) = user_id);

CREATE POLICY "Users can update own data"
    ON my_table FOR UPDATE
    USING ((SELECT auth.uid()) = user_id);

CREATE POLICY "Users can delete own data"
    ON my_table FOR DELETE
    USING ((SELECT auth.uid()) = user_id);

-- 4. Create indexes
CREATE INDEX idx_my_table_user_id ON my_table(user_id);
CREATE INDEX idx_my_table_created_at ON my_table(created_at DESC);
```

### Migration naming:
- Use: `supabase db diff -f add_users_table`
- Generates: `supabase/migrations/20251209120000_add_users_table.sql`

## ğŸ”§ EDGE FUNCTIONS

### Template for new function:

```typescript
// supabase/functions/my-function/index.ts
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "npm:@supabase/supabase-js@2.45.0";

serve(async (req) => {
  try {
    // Get auto-injected env vars
    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseKey = Deno.env.get("SUPABASE_ANON_KEY")!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Parse and validate input
    const { data, error } = await req.json();
    if (error) throw new Error("Invalid JSON");

    // Your logic here
    const result = await supabase.from("my_table").select("*");

    return new Response(
      JSON.stringify({ success: true, data: result.data }),
      { headers: { "Content-Type": "application/json" } }
    );
  } catch (error) {
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 400, headers: { "Content-Type": "application/json" } }
    );
  }
});
```

### Function structure:
- Place in: `supabase/functions/<name>/index.ts`
- Use `Deno.serve` or `serve` from std/http
- Always validate input
- Always handle errors
- Use auto-injected env vars

## ğŸ” SECURITY RULES

1. **RLS Policies:**
   - Always scope to `auth.uid()`
   - Use `SECURITY DEFINER` functions for complex checks
   - Revoke `EXECUTE` from `anon` and `authenticated` on helper functions

2. **Storage Policies:**
   - Include in migrations
   - Use path-based policies: `bucket_id/user_id/file_name`
   - Validate paths (no directory traversal)

3. **Secrets:**
   - Never commit secrets
   - Use `supabase secrets set` for Edge Functions
   - Use environment variables for local dev

## ğŸ“Š PERFORMANCE RULES

1. **Indexes:**
   - Index every foreign key
   - Index every column in WHERE clauses
   - Index every column in RLS policies
   - Use `CREATE INDEX CONCURRENTLY` for large tables

2. **Queries:**
   - Avoid `SELECT *` in hot paths
   - Use covering indexes
   - Batch operations when possible
   - Use `EXPLAIN ANALYZE` for slow queries

3. **Realtime:**
   - Use `broadcast` with database triggers
   - Use private channels: `scope:entity:id`
   - Only broadcast significant changes

## ğŸ”„ WORKFLOW RULES

### When making database changes:

1. **Local development:**
   ```bash
   supabase start
   # Make changes in SQL or Studio
   supabase db diff -f <description>
   supabase migration up
   ```

2. **Commit to Git:**
   ```bash
   git add supabase/migrations/
   git commit -m "feat: add users table with RLS"
   git push
   ```

3. **CI/CD:**
   - GitHub Actions automatically applies migrations on merge to `main`
   - No manual production edits needed

### When creating Edge Functions:

1. **Create function:**
   ```bash
   supabase functions new my-function
   ```

2. **Develop locally:**
   ```bash
   supabase functions serve my-function
   ```

3. **Test:**
   - Use local Supabase URL and keys
   - Test with curl or Postman

4. **Deploy:**
   - Commit to Git
   - CI/CD automatically deploys on merge

## ğŸ§ª TESTING RULES

1. **Migrations:**
   - Test with `supabase db reset` (recreates DB)
   - Ensure migrations are idempotent (use `IF NOT EXISTS`)
   - Test rollback scenarios

2. **Functions:**
   - Test locally first
   - Test error cases
   - Test with different user roles

3. **RLS:**
   - Test with multiple users
   - Test with service role
   - Test with anonymous users

## ğŸ“ CODE QUALITY

1. **SQL:**
   - Use `IF NOT EXISTS` for safety
   - Use `CONCURRENTLY` for indexes on large tables
   - Comment complex logic
   - One migration per change set

2. **TypeScript:**
   - Use TypeScript types
   - Validate all inputs
   - Handle all errors
   - Use structured logging

3. **Documentation:**
   - Comment complex migrations
   - Document RLS policies
   - Document function parameters

## ğŸš¨ COMMON MISTAKES TO AVOID

1. âŒ Creating tables without RLS
2. âŒ Forgetting indexes on foreign keys
3. âŒ Using unpinned imports
4. âŒ Editing production DB directly
5. âŒ Committing secrets
6. âŒ Skipping error handling
7. âŒ Using `SELECT *` in hot paths
8. âŒ Creating migrations without testing locally

## âœ… CHECKLIST FOR AI AGENTS

Before committing any database or function changes:

- [ ] Migration file created via `supabase db diff`
- [ ] RLS enabled on all new tables
- [ ] Policies created for all operations
- [ ] Indexes created for foreign keys and WHERE clauses
- [ ] Migration tested locally with `supabase db reset`
- [ ] Edge Function uses pinned imports
- [ ] Edge Function validates input
- [ ] Edge Function handles errors
- [ ] No secrets committed
- [ ] Code follows project structure

## ğŸ¯ QUICK REFERENCE

**Create migration:**
```bash
supabase db diff -f add_feature_name
```

**Apply migrations:**
```bash
supabase migration up
```

**Reset local DB:**
```bash
supabase db reset
```

**Create function:**
```bash
supabase functions new my-function
```

**Serve function locally:**
```bash
supabase functions serve my-function
```

**Deploy function:**
```bash
supabase functions deploy my-function
```

**Set secrets:**
```bash
supabase secrets set KEY=value
```

---

**Remember:** All changes flow: Local â†’ Git â†’ CI/CD â†’ Supabase Cloud
**Never edit production directly!**

